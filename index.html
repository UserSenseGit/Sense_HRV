<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sense HRV</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <style>
        body { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        .segment-card { border-left-width: 6px; transition: all 0.2s; }
        .segment-bypassed { opacity: 0.4; filter: grayscale(1); border-left-color: #94a3b8 !important; }
        
        #toast {
            position: fixed; top: 15px; left: 50%; transform: translate(-50%, -200%);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 10000;
        }
        #toast.show { transform: translate(-50%, 0); opacity: 1; }
        
        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 40;
            background-color: #f8fafc;
            padding-bottom: 1rem;
        }

        .chart-container { position: relative; height: 280px; width: 100%; }
        input[type="number"]::-webkit-inner-spin-button { display: none; }
        .trim-btn { @apply w-10 h-10 flex items-center justify-center bg-slate-100 rounded-lg active:bg-slate-200 font-bold text-slate-700 shadow-sm text-lg; }
        
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #cbd5e1; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #3b82f6; }
        input:checked + .slider:before { transform: translateX(20px); }
    </style>
</head>
<body class="bg-slate-50 min-h-screen font-sans text-slate-900 select-none">

    <div class="max-w-md mx-auto p-4 pb-24">
        <header class="flex justify-between items-center mb-4">
            <div>
                <h1 class="text-xl font-black text-slate-800 tracking-tighter uppercase leading-none">Sense HRV</h1>
                <div class="flex items-center gap-2 mt-1">
                    <div id="statusDot" class="w-2 h-2 bg-red-500 rounded-full"></div>
                    <span id="statusText" class="text-[9px] font-bold text-slate-400 uppercase tracking-widest leading-none">Disconnected</span>
                </div>
            </div>
            <button id="connectBtn" class="bg-slate-900 text-white text-[9px] font-black uppercase px-4 py-2 rounded-xl shadow-lg active:scale-95 transition-all">Connect</button>
        </header>

        <div class="sticky-header">
            <!-- Global Results -->
            <div id="resultCard" class="hidden bg-white border-2 border-slate-900 p-4 rounded-[2rem] shadow-xl mb-3 overflow-hidden">
                <div class="flex justify-between items-center mb-2 px-2">
                    <span class="text-[8px] font-black text-slate-400 uppercase tracking-[0.2em]">HRV4Training Manual Input</span>
                    <span id="activeCount" class="text-[8px] font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded-full leading-none">0 segments</span>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div class="text-center bg-slate-50 p-3 rounded-2xl">
                        <span class="text-[8px] font-black text-slate-400 uppercase">Avg HR</span>
                        <div class="text-3xl font-mono font-black text-slate-800" id="resHR">--</div>
                    </div>
                    <div class="text-center bg-slate-50 p-3 rounded-2xl">
                        <span class="text-[8px] font-black text-blue-600 uppercase">RMSSD</span>
                        <div class="text-3xl font-mono font-black text-slate-800" id="resRMSSD">--</div>
                    </div>
                </div>
            </div>

            <!-- Chart -->
            <section class="bg-white p-3 rounded-[2rem] shadow-md border border-slate-100 overflow-hidden">
                <div class="flex justify-between items-center mb-2 px-2">
                    <div class="flex flex-col gap-1">
                        <h2 class="text-[8px] font-black uppercase text-slate-400 tracking-widest leading-none text-red-500">BPM Tachogram</h2>
                        <div class="flex items-center gap-2 mt-1">
                            <label class="switch">
                                <input type="checkbox" id="segmentToggle">
                                <span class="slider"></span>
                            </label>
                            <span class="text-[8px] font-black uppercase text-slate-500">Create Segments</span>
                        </div>
                    </div>
                    <button id="resetZoom" class="text-[8px] font-black text-blue-500 uppercase bg-blue-50 px-2 py-1 rounded-full leading-none">Reset Zoom</button>
                </div>
                <div class="chart-container">
                    <canvas id="mainChart"></canvas>
                </div>
            </section>
        </div>

        <main class="mt-2 space-y-4">
            <!-- Live Dashboard -->
            <section class="bg-white p-5 rounded-[2rem] shadow-sm border border-slate-100 relative overflow-hidden">
                <div id="timerDisplay" class="hidden absolute inset-0 bg-slate-900 flex flex-col items-center justify-center text-white z-10 p-4 text-center">
                    <span class="text-[9px] font-black uppercase tracking-[0.3em] opacity-60 mb-1 leading-none">Recording...</span>
                    <div id="countdown" class="text-5xl font-mono font-black mb-4 leading-none">00:00</div>
                    <div class="flex gap-2 w-full max-w-[280px]">
                        <button id="swallowBtn" class="flex-1 bg-purple-600 text-white py-3 rounded-xl font-black uppercase text-[10px] shadow-lg active:scale-90 transition-all">Swallow</button>
                        <button id="stopEarlyBtn" class="bg-slate-700 text-white px-4 py-3 rounded-xl font-black uppercase text-[10px] active:bg-red-600">Stop</button>
                    </div>
                </div>

                <div class="flex items-center justify-between mb-4">
                    <div class="flex flex-col">
                        <span class="text-[8px] font-black text-slate-300 uppercase leading-none mb-1">Signal Quality</span>
                        <div id="qualityIndicator" class="flex items-center gap-2 px-2 py-1 bg-slate-100 rounded-full text-slate-400">
                            <div id="qualityDot" class="w-1.5 h-1.5 rounded-full bg-current"></div>
                            <span id="qualityText" class="text-[8px] font-black uppercase tracking-widest">No Data</span>
                        </div>
                    </div>
                    <div class="text-right">
                        <span class="text-[8px] font-black text-slate-300 uppercase leading-none mb-1">Live HR</span>
                        <div class="flex items-baseline justify-end gap-1">
                            <span id="liveHR" class="text-xl font-mono font-black text-red-500 leading-none">--</span>
                            <span class="text-[8px] font-bold text-slate-300 uppercase tracking-widest leading-none">BPM</span>
                        </div>
                    </div>
                </div>

                <div class="flex gap-3">
                    <select id="duration" class="flex-1 bg-slate-50 text-[10px] font-black py-3 px-4 rounded-xl outline-none uppercase tracking-widest border border-slate-100">
                        <option value="60">1 Minute</option>
                        <option value="120">2 Minutes</option>
                        <option value="180" selected>3 Minutes</option>
                        <option value="300">5 Minutes</option>
                    </select>
                    <button id="recordBtn" disabled class="flex-[2] bg-slate-200 text-slate-400 py-3 rounded-xl font-black uppercase tracking-widest text-xs shadow-md transition-all">Start Recording</button>
                </div>
            </section>

            <!-- Auto-Filter -->
            <section class="bg-white p-5 rounded-[2rem] shadow-sm border border-slate-100">
                <h2 class="text-[9px] font-black uppercase text-slate-400 mb-4 tracking-widest leading-none">Auto-Filter</h2>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="bg-slate-50 p-3 rounded-2xl flex flex-col items-center">
                        <span class="text-[8px] font-black text-slate-400 uppercase mb-2 leading-none text-center">Floor</span>
                        <input type="number" id="limitMin" value="45" class="bg-transparent text-xl font-mono font-black text-center w-full outline-none text-slate-700 leading-none">
                    </div>
                    <div class="bg-slate-50 p-3 rounded-2xl flex flex-col items-center border-l border-white">
                        <span class="text-[8px] font-black text-slate-400 uppercase mb-2 leading-none text-center">Ceiling</span>
                        <input type="number" id="limitMax" value="85" class="bg-transparent text-xl font-mono font-black text-center w-full outline-none text-slate-700 leading-none">
                    </div>
                </div>
                <button id="autoSegmentBtn" class="w-full py-2.5 bg-blue-50 text-blue-600 rounded-xl text-[9px] font-black uppercase tracking-widest active:bg-blue-100 transition-colors">Apply Auto-Filter</button>
            </section>

            <!-- Segments -->
            <section id="segmentSection" class="hidden bg-white p-5 rounded-[2rem] shadow-sm border border-slate-100">
                <div class="flex justify-between items-center mb-6 px-1">
                    <h2 class="text-[10px] font-black uppercase text-slate-400 tracking-widest leading-none">Segments</h2>
                    <button id="resetSegments" class="text-[10px] font-black text-red-500 uppercase leading-none">Clear All</button>
                </div>
                <div id="segmentList" class="space-y-6"></div>
            </section>

            <!-- History Section -->
            <section id="historySection" class="bg-white p-5 rounded-[2rem] shadow-sm border border-slate-100 mb-8">
                <h2 class="text-[10px] font-black uppercase text-slate-400 mb-4 tracking-widest leading-none">History (Cloud)</h2>
                <div id="historyList" class="space-y-3">
                    <p class="text-[10px] text-slate-400 italic text-center py-4">Loading history...</p>
                </div>
            </section>
        </main>
    </div>

    <div id="toast" class="bg-slate-900 text-white px-6 py-4 rounded-3xl shadow-2xl flex flex-col items-center text-center">
        <span id="tMsg" class="font-black text-xs uppercase tracking-widest"></span>
        <span id="tSub" class="text-[9px] opacity-60 mt-1 font-bold"></span>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, getDocs, deleteDoc, query, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAnalytics } from "firebase/analytics";

        // --- Firebase Setup ---
        const firebaseConfig = {
            apiKey: "AIzaSyB8KbT2kJ9nF29MZksTEADcCGpqjk3T_Ys",
            authDomain: "sense-hrv.firebaseapp.com",
            projectId: "sense-hrv",
            storageBucket: "sense-hrv.firebasestorage.app",
            messagingSenderId: "1051307537583",
            appId: "1:1051307537583:web:e116fc6ff5bd011d94505a",
            measurementId: "G-5V8CYX16HG"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'sense-hrv';

        let currentUser = null;

        // --- App Logic ---
        const COLORS = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#f97316', '#22c55e', '#ef4444', '#6366f1'];
        let device, hrChar, recording = false, startTime = 0, timerInterval;
        let data = [], segments = [], selStart = null, swallowMarks = [], chart;
        let lastRRIntervals = [];
        let lastSyncTime = 0; // For automatic saving during recording

        const ui = {
            connect: document.getElementById('connectBtn'),
            record: document.getElementById('recordBtn'),
            status: document.getElementById('statusText'),
            dot: document.getElementById('statusDot'),
            liveHR: document.getElementById('liveHR'),
            qualityText: document.getElementById('qualityText'),
            qualityDot: document.getElementById('qualityDot'),
            qualityInd: document.getElementById('qualityIndicator'),
            resCard: document.getElementById('resultCard'),
            resHR: document.getElementById('resHR'),
            resRMSSD: document.getElementById('resRMSSD'),
            activeCount: document.getElementById('activeCount'),
            duration: document.getElementById('duration'),
            timerDisplay: document.getElementById('timerDisplay'),
            countdown: document.getElementById('countdown'),
            stopEarly: document.getElementById('stopEarlyBtn'),
            swallow: document.getElementById('swallowBtn'),
            segList: document.getElementById('segmentList'),
            segSection: document.getElementById('segmentSection'),
            resetSeg: document.getElementById('resetSegments'),
            autoSeg: document.getElementById('autoSegmentBtn'),
            resetZoom: document.getElementById('resetZoom'),
            toast: document.getElementById('toast'),
            tMsg: document.getElementById('tMsg'),
            tSub: document.getElementById('tSub'),
            limitMin: document.getElementById('limitMin'),
            limitMax: document.getElementById('limitMax'),
            segmentToggle: document.getElementById('segmentToggle'),
            historyList: document.getElementById('historyList')
        };

        // Initialize Firebase Auth (Rule 3)
        async function initAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed:", error);
                notify("Auth Error", "Cloud features disabled");
            }
        }

        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            if (user) {
                loadHistory();
                checkActiveSession(); // Check for interrupted recordings
            }
        });

        function initChart() {
            const ctx = document.getElementById('mainChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets: [{
                    data: [], borderColor: '#94a3b8', backgroundColor: 'rgba(148, 163, 184, 0.05)',
                    borderWidth: 2, pointRadius: 4, pointHoverRadius: 10,
                    hitRadius: 35, pointHitRadius: 35, tension: 0.1, fill: true
                }]},
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'linear', display: true, grid: { display: false } },
                        y: { suggestedMin: 40, suggestedMax: 100, grid: { color: '#f1f5f9' }, ticks: { font: { size: 9, weight: 'bold' } } }
                    },
                    plugins: {
                        legend: { display: false },
                        zoom: { pan: { enabled: true, mode: 'x' }, zoom: { pinch: { enabled: true }, mode: 'x' } }
                    },
                    onClick: (e) => {
                        const pts = chart.getElementsAtEventForMode(e, 'nearest', { intersect: false }, true);
                        if (pts.length > 0) handlePointClick(pts[0].index);
                    }
                }
            });
        }

        async function connect() {
            try {
                notify("Searching...", "Pair your sensor");
                device = await navigator.bluetooth.requestDevice({ filters: [{ services: ['heart_rate'] }] });
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService('heart_rate');
                hrChar = await service.getCharacteristic('heart_rate_measurement');
                await hrChar.startNotifications();
                
                hrChar.addEventListener('characteristicvaluechanged', (e) => {
                    const v = e.target.value;
                    const flags = v.getUint8(0);
                    let off = 1;
                    const hr = (flags & 1) ? v.getUint16(off, true) : v.getUint8(off);
                    off += (flags & 1) ? 2 : 1;
                    ui.liveHR.innerText = hr;
                    if (flags & 16) {
                        for (; off + 1 < v.byteLength; off += 2) {
                            const rr = Math.round((v.getUint16(off, true) / 1024) * 1000);
                            updateQuality(rr);
                            if (recording) {
                                const time = (Date.now() - startTime) / 1000;
                                data.push({ t: time, rr: rr, bpm: 60000 / rr });
                                updateChart();
                                
                                // Auto-sync every 2 seconds to prevent data loss on refresh
                                if (Date.now() - lastSyncTime > 2000) {
                                    syncActiveSession();
                                    lastSyncTime = Date.now();
                                }
                            }
                        }
                    }
                });
                ui.status.innerText = device.name;
                ui.dot.classList.replace('bg-red-500', 'bg-green-500');
                ui.record.disabled = false;
                ui.record.classList.replace('bg-slate-200', 'bg-slate-900');
                ui.record.classList.replace('text-slate-400', 'text-white');
                notify("Connected", device.name);
            } catch (err) { notify("Error", err.message); }
        }

        function updateQuality(rr) {
            lastRRIntervals.push(rr);
            if (lastRRIntervals.length > 10) lastRRIntervals.shift();
            if (lastRRIntervals.length < 5) return;
            const avg = lastRRIntervals.reduce((a,b)=>a+b,0) / lastRRIntervals.length;
            const avgDiff = lastRRIntervals.map(v => Math.abs(v - avg)).reduce((a,b)=>a+b,0) / lastRRIntervals.length;
            const variation = (avgDiff / avg) * 100;
            let label = "Good", color = "text-green-500", bg = "bg-green-50";
            if (variation > 30) { label = "Poor"; color = "text-red-500"; bg = "bg-red-50"; }
            else if (variation > 15) { label = "Fair"; color = "text-orange-500"; bg = "bg-orange-50"; }
            ui.qualityText.innerText = label;
            ui.qualityInd.className = `flex items-center gap-2 px-2 py-1 ${bg} ${color} rounded-full transition-all quality-glow`;
        }

        function startRecording() {
            data = []; segments = []; swallowMarks = []; selStart = null;
            startTime = Date.now(); recording = true;
            lastSyncTime = Date.now();
            ui.timerDisplay.classList.remove('hidden');
            ui.resCard.classList.add('hidden');
            ui.segSection.classList.add('hidden');
            chart.data.datasets[0].data = [];
            chart.resetZoom(); chart.update();
            
            // Create initial empty active session in cloud
            syncActiveSession();

            const totalTime = parseInt(ui.duration.value);
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const remaining = totalTime - elapsed;
                if (remaining <= 0) stopRecording();
                else {
                    const mins = Math.floor(remaining / 60);
                    const secs = remaining % 60;
                    ui.countdown.innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        async function stopRecording() {
            clearInterval(timerInterval);
            recording = false;
            ui.timerDisplay.classList.add('hidden');
            if (data.length) {
                ui.segSection.classList.remove('hidden');
                await saveToCloud();
                await clearActiveSession(); // Cleanup interrupted cache
            }
            notify("Finished", "Syncing to cloud...");
            updateChart();
        }

        // --- Cloud Operations (Rules 1 & 2) ---

        // NEW: Sync current data during recording
        async function syncActiveSession() {
            if (!currentUser || !recording) return;
            try {
                const activeRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'active', 'current');
                await setDoc(activeRef, {
                    startTime: startTime,
                    data: data,
                    swallowMarks: swallowMarks,
                    duration: ui.duration.value,
                    lastUpdated: serverTimestamp()
                });
            } catch (e) {
                console.error("Sync failed:", e);
            }
        }

        // NEW: Check for interrupted sessions on load
        async function checkActiveSession() {
            if (!currentUser) return;
            try {
                const activeRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'active', 'current');
                const snap = await getDoc(activeRef);
                if (snap.exists()) {
                    const s = snap.data();
                    // If the session is older than 30 minutes, ignore it, otherwise offer recovery
                    const ageInMs = Date.now() - (s.lastUpdated?.toMillis() || 0);
                    if (ageInMs < 1800000 && s.data.length > 0) {
                        data = s.data;
                        swallowMarks = s.swallowMarks || [];
                        startTime = s.startTime;
                        ui.duration.value = s.duration;
                        ui.segSection.classList.remove('hidden');
                        updateChart();
                        notify("Recovered!", "Interrupted session restored");
                    }
                }
            } catch (e) {
                console.error("Recovery check failed:", e);
            }
        }

        async function clearActiveSession() {
            if (!currentUser) return;
            try {
                const activeRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'active', 'current');
                await deleteDoc(activeRef);
            } catch (e) {
                console.error("Cleanup failed:", e);
            }
        }

        async function saveToCloud() {
            if (!currentUser) return;
            try {
                const sessionId = `session_${Date.now()}`;
                const sessionRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'sessions', sessionId);
                await setDoc(sessionRef, {
                    timestamp: serverTimestamp(),
                    duration: ui.duration.value,
                    data: data,
                    swallowMarks: swallowMarks,
                    segments: segments
                });
                loadHistory();
            } catch (e) {
                console.error("Save failed:", e);
                notify("Cloud Error", "Failed to save session");
            }
        }

        async function loadHistory() {
            if (!currentUser) return;
            try {
                const q = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'sessions');
                const snapshot = await getDocs(q);
                const sessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                sessions.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));

                ui.historyList.innerHTML = sessions.length ? '' : '<p class="text-[10px] text-slate-400 italic text-center py-4">No sessions saved yet.</p>';
                
                sessions.slice(0, 10).forEach(s => {
                    const date = s.timestamp ? s.timestamp.toDate().toLocaleString() : 'Saving...';
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center p-3 bg-slate-50 rounded-2xl border border-slate-100 active:scale-[0.98] transition-transform";
                    div.innerHTML = `
                        <div class="flex flex-col gap-0.5" onclick="loadSession('${s.id}')">
                            <span class="text-[9px] font-black text-slate-800 uppercase leading-none">${date}</span>
                            <span class="text-[8px] font-bold text-slate-400 uppercase tracking-widest">${s.duration}s Session</span>
                        </div>
                        <button onclick="deleteSession('${s.id}')" class="text-red-400 text-lg px-2">&times;</button>
                    `;
                    ui.historyList.appendChild(div);
                });
            } catch (e) {
                console.error("Load failed:", e);
            }
        }

        window.loadSession = async (id) => {
            if (!currentUser) return;
            notify("Loading...", "Fetching data");
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'sessions', id);
            const snap = await getDoc(docRef);
            if (snap.exists()) {
                const s = snap.data();
                data = s.data;
                swallowMarks = s.swallowMarks || [];
                segments = s.segments || [];
                ui.segSection.classList.remove('hidden');
                updateChart();
                updateUI();
                notify("Loaded", "Session restored");
            }
        };

        window.deleteSession = async (id) => {
            if (!currentUser || !confirm("Delete this session from cloud?")) return;
            try {
                await deleteDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'sessions', id));
                loadHistory();
                notify("Deleted", "Session removed");
            } catch (e) { console.error(e); }
        };

        ui.swallow.onclick = () => {
            if (!recording) return;
            swallowMarks.push((Date.now() - startTime) / 1000);
            notify("Swallow Marked", "Interval logged");
        };

        function autoSegment() {
            if (!data.length) return;
            segments = [];
            const min = parseInt(ui.limitMin.value) || 0;
            const max = parseInt(ui.limitMax.value) || 250;
            let currentS = null;
            for (let i = 0; i < data.length; i++) {
                const inRange = data[i].bpm >= min && data[i].bpm <= max;
                if (inRange && currentS === null) currentS = i;
                else if (!inRange && currentS !== null) {
                    if (i - 1 > currentS) segments.push({ s: currentS, e: i - 1, bypassed: false, color: COLORS[segments.length % COLORS.length] });
                    currentS = null;
                }
            }
            if (currentS !== null && (data.length - 1) > currentS) {
                segments.push({ s: currentS, e: data.length - 1, bypassed: false, color: COLORS[segments.length % COLORS.length] });
            }
            updateUI();
        }

        function handlePointClick(idx) {
            if (recording) return;
            if (!ui.segmentToggle.checked) {
                const point = data[idx];
                notify(`Beat Info`, `${point.bpm.toFixed(1)} BPM at ${point.t.toFixed(1)}s`);
                return;
            }
            if (selStart === null) {
                selStart = idx;
                notify("Selection Start", "Pick an end point");
            } else {
                const s = Math.min(selStart, idx), e = Math.max(selStart, idx);
                if (s !== e) {
                    segments.push({ s, e, bypassed: false, color: COLORS[segments.length % COLORS.length] });
                    updateUI();
                }
                selStart = null;
            }
        }

        window.trimStart = (i, delta) => {
            const seg = segments[i];
            const newS = seg.s + delta;
            if (newS >= 0 && newS < seg.e) { seg.s = newS; updateUI(); }
        };

        window.trimEnd = (i, delta) => {
            const seg = segments[i];
            const newE = seg.e + delta;
            if (newE > seg.s && newE < data.length) { seg.e = newE; updateUI(); }
        };

        function updateChart() {
            chart.data.datasets[0].data = data.map(d => ({ x: d.t, y: d.bpm }));
            chart.data.datasets[0].pointBackgroundColor = data.map((d, i) => {
                const seg = segments.find(s => i >= s.s && i <= s.e);
                if (!seg) return '#94a3b8';
                return seg.bypassed ? '#cbd5e1' : seg.color;
            });
            chart.data.datasets[0].pointRadius = data.map((d, i) => {
                if (swallowMarks.some(t => Math.abs(d.t - t) < 0.8)) return 8;
                return segments.some(s => i >= s.s && i <= s.e) ? 6 : 2;
            });
            chart.data.datasets[0].pointBorderColor = data.map(d => swallowMarks.some(t => Math.abs(d.t - t) < 0.8) ? '#a855f7' : 'transparent');
            chart.data.datasets[0].pointBorderWidth = data.map(d => swallowMarks.some(t => Math.abs(d.t - t) < 0.8) ? 4 : 0);
            chart.update('none');
        }

        function updateUI() {
            ui.segList.innerHTML = '';
            let activeSegCount = 0;
            segments.forEach((seg, i) => {
                const slice = data.slice(seg.s, seg.e + 1).map(d => d.rr);
                if (slice.length < 2) return;
                if (!seg.bypassed) activeSegCount++;
                const stats = calcSliceStats(slice);
                const el = document.createElement('div');
                el.className = `p-5 rounded-3xl transition-all segment-card bg-white shadow-lg border border-slate-100 ${seg.bypassed ? 'segment-bypassed' : ''}`;
                el.style.borderLeftColor = seg.color;
                el.innerHTML = `
                    <div class="flex flex-col gap-4">
                        <div class="flex justify-between items-start">
                            <div class="flex flex-col">
                                <div class="flex items-center gap-2 mb-1">
                                    <div class="w-2.5 h-2.5 rounded-full" style="background-color: ${seg.color}"></div>
                                    <span class="text-[11px] font-black text-slate-800 uppercase leading-none">Segment ${i+1}</span>
                                </div>
                                <div class="flex gap-4 mt-1">
                                    <div class="flex flex-col"><span class="text-[8px] font-black text-slate-400 uppercase leading-none mb-1">HR</span><span class="text-base font-mono font-black text-slate-700">${Math.round(stats.hr)}</span></div>
                                    <div class="flex flex-col"><span class="text-[8px] font-black text-slate-400 uppercase leading-none mb-1">RMSSD</span><span class="text-base font-mono font-black" style="color: ${seg.color}">${stats.rmssd.toFixed(1)}</span></div>
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="toggleBypass(${i})" class="text-[9px] font-black uppercase px-3 py-2 rounded-xl border border-slate-200 active:bg-slate-100 shadow-sm">Bypass</button>
                                <button onclick="removeSeg(${i})" class="bg-red-50 text-red-500 font-bold text-xl w-10 h-10 flex items-center justify-center rounded-xl">&times;</button>
                            </div>
                        </div>
                        <div class="flex items-center justify-between border-t border-slate-50 pt-4 gap-4">
                            <div class="flex flex-col gap-1 flex-1">
                                <span class="text-[8px] font-black text-slate-300 uppercase text-center">Start Time</span>
                                <div class="flex items-center justify-center gap-2">
                                    <button onclick="trimStart(${i}, -1)" class="trim-btn">-</button>
                                    <span class="text-xs font-black text-slate-700 w-10 text-center">${data[seg.s].t.toFixed(0)}s</span>
                                    <button onclick="trimStart(${i}, 1)" class="trim-btn">+</button>
                                </div>
                            </div>
                            <div class="flex flex-col gap-1 flex-1 border-l border-slate-50 pl-4">
                                <span class="text-[8px] font-black text-slate-300 uppercase text-center">End Time</span>
                                <div class="flex items-center justify-center gap-2">
                                    <button onclick="trimEnd(${i}, -1)" class="trim-btn">-</button>
                                    <span class="text-xs font-black text-slate-700 w-10 text-center">${data[seg.e].t.toFixed(0)}s</span>
                                    <button onclick="trimEnd(${i}, 1)" class="trim-btn">+</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                ui.segList.appendChild(el);
            });
            ui.activeCount.innerText = `${activeSegCount} active segments`;
            updateChart(); calculateGlobal();
        }

        function calcSliceStats(rrList) {
            const avg = rrList.reduce((a,b)=>a+b,0) / rrList.length;
            let sumSq = 0;
            for(let i=0; i<rrList.length-1; i++) sumSq += Math.pow(rrList[i+1] - rrList[i], 2);
            return { hr: 60000/avg, rmssd: Math.sqrt(sumSq / (rrList.length-1)) };
        }

        window.toggleBypass = (i) => { segments[i].bypassed = !segments[i].bypassed; updateUI(); };
        window.removeSeg = (i) => { segments.splice(i, 1); updateUI(); };
        ui.resetSeg.onclick = () => { segments = []; swallowMarks = []; updateUI(); };
        ui.autoSeg.onclick = autoSegment;
        ui.resetZoom.onclick = () => chart.resetZoom();

        function calculateGlobal() {
            const active = segments.filter(s => !s.bypassed);
            if (!active.length) { ui.resCard.classList.add('hidden'); return; }
            let totalSq = 0, diffCount = 0, rrSum = 0, beatCount = 0;
            active.forEach(seg => {
                const rr = data.slice(seg.s, seg.e + 1).map(d => d.rr);
                beatCount += rr.length; rrSum += rr.reduce((a,b)=>a+b,0);
                for(let i=0; i<rr.length-1; i++) { totalSq += Math.pow(rr[i+1] - rr[i], 2); diffCount++; }
            });
            if (diffCount === 0) return;
            ui.resHR.innerText = Math.round(60000 / (rrSum / beatCount));
            ui.resRMSSD.innerText = Math.sqrt(totalSq / diffCount).toFixed(1);
            ui.resCard.classList.remove('hidden');
        }

        function notify(m, s = "") { ui.tMsg.innerText = m; ui.tSub.innerText = s; ui.toast.classList.add('show'); setTimeout(() => ui.toast.classList.remove('show'), 3000); }
        
        ui.connect.onclick = connect; 
        ui.record.onclick = startRecording; 
        ui.stopEarly.onclick = stopRecording;
        
        window.onload = () => {
            initAuth();
            initChart();
        };
    </script>
</body>
</html>